<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32 HAL库常见函数汇总</title>
    <link href="/2024/11/07/stm32-hal/"/>
    <url>/2024/11/07/stm32-hal/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>前提要求： 具备基本电路知识基础。</p>          </div><div class="note note-success">            <p>本文包含了常见的STM32 HAL库中基本操作函数的整理。</p><p>为方便查阅，在每个模块前包含表格，包括全部该模块的封装函数内容，可点击跳转详细查看其用法。</p>          </div><h2 id="HAL-GPIO-Generic-Driver"><a href="#HAL-GPIO-Generic-Driver" class="headerlink" title="HAL GPIO Generic Driver"></a>HAL GPIO Generic Driver</h2><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td><a href="#HAL-GPIO-Init">HAL_GPIO_Init</a></td><td>初始化</td></tr><tr><td><a href="#HAL-GPIO-DeInit">HAL_GPIO_DeInit</a></td><td>反初始化</td></tr><tr><td><a href="#HAL-GPIO-ReadPin">HAL_GPIO_ReadPin</a></td><td>读取引脚状态</td></tr><tr><td><a href="#HAL-GPIO-WritePin">HAL_GPIO_WritePin</a></td><td>输出引脚</td></tr><tr><td><a href="#HAL-GPIO-TogglePin">HAL_GPIO_TogglePin</a></td><td>反转引脚</td></tr><tr><td><a href="#HAL-GPIO-LockPin">HAL_GPIO_LockPin</a></td><td>锁引脚</td></tr><tr><td><a href="#HAL-GPIO_EXTI-IRQHandler">HAL_GPIO_EXTI_IRQHandler</a></td><td>外部中断请求</td></tr><tr><td><a href="#HAL-GPIO-EXTI-Callback">HAL_GPIO_EXTI_Callback</a></td><td>外部中断回调</td></tr></tbody></table><h3 id="HAL-GPIO-Init"><a href="#HAL-GPIO-Init" class="headerlink" title="HAL_GPIO_Init"></a>HAL_GPIO_Init</h3><h4 id="函数名称"><a href="#函数名称" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_Init</span> <span class="hljs-params">(GPIO_TypeDef * GPIOx, GPIO_InitTypeDef * GPIO_Init)</span><br></code></pre></td></tr></table></figure><h4 id="函数描述"><a href="#函数描述" class="headerlink" title="函数描述"></a>函数描述</h4><p>根据 GPIO_Init 中指定的参数初始化 GPIOx 外设。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIOx: x 可以是 (A..I)选择</li><li>GPIO_Init：指向包含指定 GPIO 外设配置信息的 GPIO_InitTypeDef 结构的指针。</li><li>返回值：无。</li></ul><h3 id="HAL-GPIO-DeInit"><a href="#HAL-GPIO-DeInit" class="headerlink" title="HAL_GPIO_DeInit"></a>HAL_GPIO_DeInit</h3><h4 id="函数名称-1"><a href="#函数名称-1" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_DeInit</span> <span class="hljs-params">(GPIO_TypeDef * GPIOx, <span class="hljs-type">uint32_t</span> GPIO_Pin)</span><br></code></pre></td></tr></table></figure><h4 id="函数描述-1"><a href="#函数描述-1" class="headerlink" title="函数描述"></a>函数描述</h4><p>将 GPIOx 外设寄存器取消初始化为其默认复位值。</p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIOx：其中 x 可以是 (A..I) 选择 GPIO 外设。</li><li>GPIO_Pin：指定要写入的端口位。此参数可以是其中 x 可以是 (0..15) 的GPIO_PIN_x之一。</li><li>返回值： 无。</li></ul><h3 id="HAL-GPIO-ReadPin"><a href="#HAL-GPIO-ReadPin" class="headerlink" title="HAL_GPIO_ReadPin"></a>HAL_GPIO_ReadPin</h3><h4 id="函数名称-2"><a href="#函数名称-2" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">GPIO_PinState <span class="hljs-title function_">HAL_GPIO_ReadPin</span> <span class="hljs-params">(GPIO_TypeDef * GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span><br></code></pre></td></tr></table></figure><h4 id="函数说明-读取指定的输入端口引脚。"><a href="#函数说明-读取指定的输入端口引脚。" class="headerlink" title="函数说明 读取指定的输入端口引脚。"></a>函数说明 读取指定的输入端口引脚。</h4><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIOx：其中 x 可以是 (A..I) 选择 GPIO 外设。</li><li>GPIO_Pin：指定要读取的端口位。此参数可以GPIO_PIN_x，其中 x 可以是 (0..15)。</li><li>返回值：输入端口引脚值。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 读取 PB11 状态，若为低电平，执行语句。</span><br><span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_11) == GPIO_PIN_RESET)<br>&#123;<br>  <span class="hljs-comment">// 语句块</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HAL-GPIO-WritePin"><a href="#HAL-GPIO-WritePin" class="headerlink" title="HAL_GPIO_WritePin"></a>HAL_GPIO_WritePin</h3><h4 id="函数名称-3"><a href="#函数名称-3" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_WritePin</span> <span class="hljs-params">(GPIO_TypeDef * GPIOx， <span class="hljs-type">uint16_t</span> GPIO_Pin， GPIO_PinState PinState)</span><br></code></pre></td></tr></table></figure><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><p>设置或清除选定的数据端口位。</p><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIOx：其中 x 可以是 (A..I) 为所有 STM32F2XX 设备选择 GPIO 外设 </li><li>GPIO_Pin：指定要写入的端口位。此参数可以是其中 x 可以是 (0..15) 的GPIO_PIN_x之一。</li><li>PinState：指定要写入所选位的值。此参数可以是GPIO_PinState枚举值之一：<ul><li>GPIO_PIN_RESET：清除端口引脚 </li><li>GPIO_PIN_SET：设置端口引脚</li></ul></li><li>返回值：无。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 给 PB12 高电平</span><br>HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);<br></code></pre></td></tr></table></figure><blockquote><p>注释<br>此功能使用<code>GPIOx_BSRR</code>寄存器来允许原子读取&#x2F;修改访问。这样，在 read 和 modify 访问之间就不存在 IRQ 的风险。</p></blockquote><h3 id="HAL-GPIO-TogglePin"><a href="#HAL-GPIO-TogglePin" class="headerlink" title="HAL_GPIO_TogglePin"></a>HAL_GPIO_TogglePin</h3><h4 id="函数名称-4"><a href="#函数名称-4" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_TogglePin</span> <span class="hljs-params">(GPIO_TypeDef * GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span> <br></code></pre></td></tr></table></figure><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>切换指定的 GPIO 引脚。</p><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIOx：其中 x 可以是 (A..I) 选择 GPIO 外设。</li><li>GPIO_Pin：指定要切换的引脚。</li><li>返回值：无。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 反转 PB12 电平</span><br>HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_12);<br></code></pre></td></tr></table></figure><h3 id="HAL-GPIO-LockPin"><a href="#HAL-GPIO-LockPin" class="headerlink" title="HAL_GPIO_LockPin"></a>HAL_GPIO_LockPin</h3><h4 id="函数名称-5"><a href="#函数名称-5" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_GPIO_LockPin</span> <span class="hljs-params">(GPIO_TypeDef * GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span><br></code></pre></td></tr></table></figure><ul><li>函数描述 锁定 GPIO 引脚配置寄存器。</li></ul><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIOx：其中 x 可以是 (A..I) 为STM32F2XX系列选择 GPIO 外设 </li><li>GPIO_Pin：指定要锁定的端口位。此参数可以是 GPIO_PIN_x 的任意组合，其中 x 可以是 (0..15)。</li><li>返回值：无。</li></ul><blockquote><p>注释 </p><ul><li>锁定的寄存器是 GPIOx_MODER、GPIOx_OTYPER、GPIOx_OSPEEDR、GPIOx_PUPDR、GPIOx_AFRL 和 GPIOx_AFRH。</li><li>在下次重置之前，不能再修改锁定的 GPIO 引脚的配置。</li></ul></blockquote><h3 id="HAL-GPIO-EXTI-IRQHandler"><a href="#HAL-GPIO-EXTI-IRQHandler" class="headerlink" title="HAL_GPIO_EXTI_IRQHandler"></a>HAL_GPIO_EXTI_IRQHandler</h3><h4 id="函数名称-6"><a href="#函数名称-6" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_IRQHandler</span> <span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span><br></code></pre></td></tr></table></figure><h4 id="函数说明-该函数处理-EXTI-中断请求。"><a href="#函数说明-该函数处理-EXTI-中断请求。" class="headerlink" title="函数说明 该函数处理 EXTI 中断请求。"></a>函数说明 该函数处理 EXTI 中断请求。</h4><h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIO_Pin：指定引脚连接的 EXTI 线</li><li>返回值：无。</li></ul><h3 id="HAL-GPIO-EXTI-Callback"><a href="#HAL-GPIO-EXTI-Callback" class="headerlink" title="HAL_GPIO_EXTI_Callback"></a>HAL_GPIO_EXTI_Callback</h3><h4 id="函数名称-7"><a href="#函数名称-7" class="headerlink" title="函数名称"></a>函数名称</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span> <span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span><br></code></pre></td></tr></table></figure><p>函数描述 EXTI 线检测回调。</p><h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><ul><li>GPIO_Pin：指定引脚连接的 EXTI 行 </li><li>返回值：无。</li></ul>]]></content>
    
    
    <categories>
      
      <category>STM32整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器配置</title>
    <link href="/2024/07/16/old-config/"/>
    <url>/2024/07/16/old-config/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>这是半年前的记录，其中有不少问题，懒得改了。</p><p>主要内容是申请阿里云服务器，然后部署到本地免密登录，使用 vscode 的 remote 插件远程连接，并在云服务器上配置了 ssh 连接到 gitea 仓库。</p>          </div><h1 id="一些整理"><a href="#一些整理" class="headerlink" title="一些整理"></a>一些整理</h1><blockquote><p>这是我仓库崩了很多次的思考。。</p><p>为了<del>造福人类</del>，为了整理下我在搞东西遇到的问题，我写下这个东西，便于以后出现问题好搞。</p><p>这玩意我还得开个备份，仓库别没了。。</p></blockquote><blockquote><p>目录</p><p><a href="#1-rm--f-%E7%9A%84%E4%BD%9C%E7%94%A8">1.rm-rf 你值得拥有</a></p></blockquote><blockquote><p><a href="#2-%E9%87%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E9%85%8D%E7%BD%AE">2.重置服务器后配置</a></p></blockquote><blockquote><p><a href="#3-%E5%85%B3%E8%81%94%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">3.关联本地文件</a></p></blockquote><h2 id="1-rm-f-的作用"><a href="#1-rm-f-的作用" class="headerlink" title="1. rm -f&#x2F;* 的作用"></a>1. rm -f&#x2F;* 的作用</h2><p>千万不要在任何文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -f/*<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf/*<br></code></pre></td></tr></table></figure><p>起初我还以为这玩意只在当前文件夹下起作用，直到第三次把系统文件删了我才知道这玩意是直接删除根目录下所有文件，不询问。。</p><p>要是你好奇的话，可以像我一样试试。</p><p>我现在也有点奇怪那个东西，在<code>makefile</code>中编辑时有这一行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">clean:<br>    <span class="hljs-built_in">rm</span> -f bin/*<br>    <span class="hljs-built_in">rm</span> -f build/*<br></code></pre></td></tr></table></figure><p>这不是只<code>clean</code>了目标文件吗，也没把系统文件删了。</p><p>谁知道，告诉我一声。</p><h2 id="2-重置服务器重配置"><a href="#2-重置服务器重配置" class="headerlink" title="2. 重置服务器重配置"></a>2. 重置服务器重配置</h2><p><del>哈哈哈哈，你来了</del></p><h3 id="2-1-阿里云服务器重置"><a href="#2-1-阿里云服务器重置" class="headerlink" title="2.1 阿里云服务器重置"></a>2.1 阿里云服务器重置</h3><p><em>当遇到你的系统文件删了，服务器连不上什么的问题，就来重置服务器吧<br>在此之前，先看看能不能登录</em></p><p><strong>2.2.1 阿里云是否能登录</strong></p><p>打开<a href="https://cn.aliyun.com/">阿里云服务器官网</a>，找到你的系统镜像<code>Debian</code>,找到 : <em>远程连接</em>，选择第一个<code>Workbentch登录</code>，登不上就对了。</p><p>选择<code>救援登录</code>，应该能登上，但是全黑屏。</p><p>来参加光荣的重置吧！</p><p><strong>2.2.2 重置阿里云服务器</strong></p><p>点开<code>更多操作</code> -&gt; <code>重置系统</code>，可能要验证码什么的。</p><p>重置后按照2.2.1的步骤看一下是否能默认登录(不搞也没事，肯定可以)</p><p><strong>注意：重置服务器后你的文件会消失，请在此之前上传到仓库或者搞好备份</strong></p><p><strong>2.2.3 更改密码和名字</strong></p><p>找到<code>重置密码</code>按钮，可能还需要验证码。</p><p>在<code>cmd</code>中输入<code>ssh root@&lt;your_address&gt;</code>，提示输入密码（看不到），输入回车键确认，看到你的名字是乱码。</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostname<br></code></pre></td></tr></table></figure><p>查看你的用户名.</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostnamectl set-hostname &lt;yourname&gt;<br></code></pre></td></tr></table></figure><p>修改你的用户名.</p><p><em>修改后你要重新启动服务器</em></p><p><strong>2.2.4 设置免密登录</strong></p><p>找到C盘文件下的<code>.ssh</code>文件夹，清空。这是我的路径。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">C</span>:\Users\<span class="hljs-number">17273</span>\.ssh<br></code></pre></td></tr></table></figure><p>打开<code>cmd</code>，输入ssh-keygen,一路回车，生成新的密钥。</p><p>找到<code>.pub</code>结尾的文件，用记事本打开，<code>ctrl+a</code>全选复制。</p><p>打开vscode,连接到你的远程<code>ssh</code>,要输入密码。</p><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al<br></code></pre></td></tr></table></figure><p>查看你的系统文件。（我就是把这个删了）</p><p>能看到有<code>.ssh</code>文件，删了，再建一个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf .ssh<br><span class="hljs-built_in">mkdir</span> .ssh<br><span class="hljs-built_in">cd</span> .ssh<br></code></pre></td></tr></table></figure><p>在<code>.ssh</code>下将密钥保存到<code>authorized_keys</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi authorized_keys<br></code></pre></td></tr></table></figure><p>然后在键盘输入<code>i</code>,进入插入模式，<code>ctrl+v</code>粘贴，在键盘上先后输入<code>Esc+:wq</code>保存并退出。</p><p>免密登录设置完成。</p><h2 id="3-关联本地文件到远程仓库"><a href="#3-关联本地文件到远程仓库" class="headerlink" title="3. 关联本地文件到远程仓库"></a>3. 关联本地文件到远程仓库</h2><p>找到你的<code>gitea</code>用户界面，设置-&gt;SSH&#x2F;GPG密钥，删除原来的密钥。</p><p>在服务器上的<code>.ssh</code>文件夹下输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen<br></code></pre></td></tr></table></figure><p>生成新的密钥，注意，是vscode服务器上，不是C盘那里。</p><p>刷新当前文件夹，找到<code>.pub</code>文件，全选复制，粘贴到<code>gitea</code>设置密钥那里，密钥名称可以不填，没用。</p><p>至此，配置完成。</p>]]></content>
    
    
    <categories>
      
      <category>搬运的旧文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>old</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互斥锁的简单运用</title>
    <link href="/2024/07/15/old-mutex/"/>
    <url>/2024/07/15/old-mutex/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>请先掌握 <code>c/c++</code> 基本用法。</p>          </div><h2 id="多线程整理"><a href="#多线程整理" class="headerlink" title="多线程整理"></a>多线程整理</h2><h3 id="std-this-thread-用法举例"><a href="#std-this-thread-用法举例" class="headerlink" title="std::this_thread 用法举例"></a><code>std::this_thread</code> 用法举例</h3><p><code>std::this_thread</code> 是 C++ 标准库中的命名空间，提供了与当前线程相关的功能。以下是一些 <code>std::this_thread</code> 命名空间中常用的功能和用法：</p><ol><li><p><strong>std::this_thread::get_id()</strong></p><ul><li>用于获取当前线程的 ID。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>std::this_thread::sleep_for()</strong></p><ul><li>用于使当前线程休眠一段时间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Start sleeping...&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Awake after 3 seconds.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>std::this_thread::yield()</strong></p><ul><li>用于提示调度器允许其他线程运行，当前线程可能会暂时放弃 CPU 时间片。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Before yielding...&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">yield</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After yielding...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这些是 <code>std::this_thread</code> 命名空间中的一些常用方法。你可以根据需要，在程序中使用这些函数来处理线程相关的操作。</p><h3 id="std-chrono-用法举例"><a href="#std-chrono-用法举例" class="headerlink" title="std::chrono 用法举例"></a><code>std::chrono</code> 用法举例</h3><p>当您使用<code>std::chrono</code>库时，可以方便地处理时间点和持续时间。下面是一个简单的示例，展示了如何使用<code>std::chrono</code>来测量程序运行时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取程序开始时间点</span><br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-comment">// 模拟程序运行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; ++i) &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取程序结束时间点</span><br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-comment">// 计算程序运行时间</span><br>    std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; duration = end - start;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;程序运行时间: &quot;</span> &lt;&lt; duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先使用<code>std::chrono::high_resolution_clock::now()</code>获取程序开始时间点<code>start</code>，然后执行一些模拟的任务。接着，我们获取程序结束时间点<code>end</code>，并计算程序运行时间。最后，我们将程序运行时间输出到控制台。</p><p><code>std::chrono::duration</code>是一个模板类，它表示时间段。在示例中，我们使用<code>std::chrono::duration&lt;double&gt;</code>来表示持续时间，并通过<code>count()</code>方法获取持续时间的秒数。</p><p>通过使用<code>std::chrono</code>库，您可以方便地测量程序执行时间、处理时间间隔等时间相关操作。</p><h3 id="std-condition-variable-用法举例"><a href="#std-condition-variable-用法举例" class="headerlink" title="std::condition_variable 用法举例"></a><code>std::condition_variable</code> 用法举例</h3><p><code>std::condition_variable</code> 是 C++ 标准库中用于多线程编程的类之一，它通常与 <code>std::mutex</code> 一起使用来实现线程间的同步和通信。以下是它的常见用法：</p><ol><li><p><strong>等待条件变量的通知：</strong> 线程可以通过调用 <code>wait()</code> 函数来等待条件变量的通知。在等待过程中，线程会释放与 <code>std::unique_lock&lt;std::mutex&gt;</code> 相关联的互斥锁，并暂时阻塞。当其他线程调用了 <code>notify_one()</code> 或 <code>notify_all()</code> 发送了通知时，等待的线程将被唤醒继续执行。</p></li><li><p><strong>在特定条件下等待：</strong> 通常情况下，<code>wait()</code> 函数会接受一个 lambda 函数作为参数，用于指定在收到通知前线程应该等待的特定条件。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::condition_variable cv;<br>std::mutex mtx;<br><span class="hljs-type">bool</span> someCondition = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>cv.<span class="hljs-built_in">wait</span>(lock, []&#123; <span class="hljs-keyword">return</span> someCondition; &#125;);<br><br><span class="hljs-comment">// 等待结束后，继续执行操作</span><br></code></pre></td></tr></table></figure></li><li><p><strong>发送通知：</strong> 可以调用 <code>notify_one()</code> 或 <code>notify_all()</code> 函数来发送通知给等待的线程，唤醒一个或多个等待的线程。这通常是在持有相同互斥锁的情况下进行的，以确保线程间的正确同步。</p></li></ol><p>总的来说，<code>std::condition_variable</code> 可以帮助协调多个线程之间的操作，确保在某个特定情况满足时线程能够安全地等待或唤醒。</p><h3 id="析构互斥锁区别"><a href="#析构互斥锁区别" class="headerlink" title="析构互斥锁区别"></a>析构互斥锁区别</h3><ol><li><p><code>std::lock_guard</code> 和 <code>std::unique_lock</code> 都是用于管理互斥锁的RAII（资源获取即初始化）类，但它们之间有一些重要的区别：</p><ul><li><code>std::lock_guard</code> 是一个轻量级的互斥锁封装，一旦被构造就会锁住互斥锁，并在其生命周期结束时自动释放互斥锁。<code>std::lock_guard</code> 适用于需要在同一作用域内锁住互斥锁的简单情况。</li><li><code>std::unique_lock</code> 提供了更多的灵活性，它可以手动锁定和解锁互斥锁，并且可以延迟锁定。<code>std::unique_lock</code> 还支持条件变量的等待操作。因此，如果需要更多的控制权和灵活性，可以选择使用 <code>std::unique_lock</code>。</li></ul><p>在同一个作用域内，不建议混用 <code>std::lock_guard</code> 和 <code>std::unique_lock</code>，因为它们的行为可能会相互干扰，导致意外的行为发生。</p></li><li><p>在使用互斥锁时，<code>mtx</code> 是全局变量，可以在任何地方使用，包括在 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 中。这是因为 <code>mtx</code> 是一个全局变量，可以在整个程序中访问。</p></li><li><p><code>cv.notify_one()</code> 必须在互斥锁被锁定的情况下调用，以避免出现竞争条件。唤醒条件变量的操作通常需要与互斥锁一起使用，以确保线程安全。因此，一般情况下，<code>cv.notify_one()</code> 应该在已经锁定互斥锁的情况下调用。如果在没有锁定互斥锁的情况下调用 <code>cv.notify_one()</code>，可能会导致竞争条件和意外行为。</p></li></ol><h3 id="同锁与不同锁区别"><a href="#同锁与不同锁区别" class="headerlink" title="同锁与不同锁区别"></a>同锁与不同锁区别</h3><p>使用相同的 <code>std::mutex</code> 和不同的 <code>std::mutex</code> 之间有一些重要区别，这些区别可以影响代码的正确性和性能。让我详细说明一下：</p><h3 id="相同的-std-mutex-vs-不同的-std-mutex"><a href="#相同的-std-mutex-vs-不同的-std-mutex" class="headerlink" title="相同的 std::mutex vs. 不同的 std::mutex"></a>相同的 std::mutex vs. 不同的 std::mutex</h3><h4 id="相同的-std-mutex"><a href="#相同的-std-mutex" class="headerlink" title="相同的 std::mutex"></a>相同的 std::mutex</h4><ul><li><strong>示例</strong>：在多个线程中共享相同的资源时，你可以使用相同的 <code>std::mutex</code> 来确保对这个资源的互斥访问。</li><li><strong>优点</strong>：<ul><li>简单：只需一个互斥量来管理对共享资源的访问。</li><li>避免竞态条件：由于同一资源的互斥保护，避免了竞态条件。</li></ul></li><li><strong>缺点</strong>：<ul><li>性能：如果一个线程正在使用互斥量锁定资源，其他线程就无法同时访问任何受该互斥量保护的资源，可能会导致性能瓶颈。</li></ul></li></ul><h4 id="不同的-std-mutex"><a href="#不同的-std-mutex" class="headerlink" title="不同的 std::mutex"></a>不同的 std::mutex</h4><ul><li><strong>示例</strong>：当有多个独立的资源需要并行访问时，你可以为每个资源创建不同的 <code>std::mutex</code>。</li><li><strong>优点</strong>：<ul><li>并行性：不同的资源可以并行处理，因为它们有各自的互斥量。</li><li>性能：避免了单一互斥量成为性能瓶颈的情况。</li></ul></li><li><strong>缺点</strong>：<ul><li>复杂性：需要管理多个互斥量，可能需要更复杂的逻辑来确保正确的锁定顺序以避免死锁。</li></ul></li></ul><h3 id="不同的互斥量之间是否可以通过条件变量联系？"><a href="#不同的互斥量之间是否可以通过条件变量联系？" class="headerlink" title="不同的互斥量之间是否可以通过条件变量联系？"></a>不同的互斥量之间是否可以通过条件变量联系？</h3><p>是的，不同的互斥量之间可以通过条件变量联系。条件变量允许线程等待某个条件得到满足，并且在条件满足时通知其他线程。条件变量通常与互斥量一起使用，以便在线程等待条件变量时能够安全地释放互斥锁。</p><p>例如，在多生产者-消费者问题中，可以为每个生产者和消费者线程分配一个独立的互斥量，并使用条件变量来实现线程间的通信。当生产者生产了数据时，它可以通知消费者线程来获取数据；反之，当消费者消费完数据时，它可以通知生产者线程来生产新的数据。</p><p>总之，条件变量提供了一种方式，使得不同的互斥量之间的线程可以进行有效的协调和通信。</p>]]></content>
    
    
    <categories>
      
      <category>搬运的旧文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>old</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell 一些用法</title>
    <link href="/2024/07/15/old-shell/"/>
    <url>/2024/07/15/old-shell/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>请先掌握 <code>linux</code> 基本用法。</p>          </div><h2 id="脚本整理"><a href="#脚本整理" class="headerlink" title="脚本整理"></a>脚本整理</h2><h3 id="日志文件内容增加"><a href="#日志文件内容增加" class="headerlink" title="日志文件内容增加"></a>日志文件内容增加</h3><p><code>&gt;&gt;</code>和<code>tee -a</code>都是将输出追加到文件中的方法，但它们的使用场景略有不同。</p><p><code>&gt;&gt;</code>是一种重定向操作符，用于将命令的输出追加到指定文件的末尾。例如，以下命令将<code>ls</code>命令的输出追加到<code>list.txt</code>文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> &gt;&gt; list.txt<br></code></pre></td></tr></table></figure><p>如果<code>list.txt</code>文件不存在，则会创建该文件并将<code>ls</code>命令的输出写入其中。如果文件已经存在，则会将<code>ls</code>命令的输出追加到文件末尾。</p><p><code>tee -a</code>是一个命令，它将标准输入复制到标准输出和指定文件中。<code>-a</code>选项表示将输出追加到文件的末尾。例如，以下命令将<code>ls</code>命令的输出同时显示在终端上并追加到<code>list.txt</code>文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> | <span class="hljs-built_in">tee</span> -a list.txt<br></code></pre></td></tr></table></figure><p>如果<code>list.txt</code>文件不存在，则会创建该文件并将<code>ls</code>命令的输出写入其中。如果文件已经存在，则会将<code>ls</code>命令的输出追加到文件末尾。</p><p>因此，<code>&gt;&gt;</code>适用于将命令的输出追加到文件中，而<code>tee -a</code>适用于将命令的输出同时显示在终端上并追加到文件中。如果你只需要将输出追加到文件中，那么使用<code>&gt;&gt;</code>可能更简单和直接。如果你需要同时在终端上查看输出并将其追加到文件中，那么使用<code>tee -a</code>可能更方便。</p><h3 id="date-基本用法"><a href="#date-基本用法" class="headerlink" title="date 基本用法"></a>date 基本用法</h3><p><code>date</code>命令用于显示或设置系统的日期和时间。在命令行中，你可以使用<code>date</code>命令来获取当前日期和时间，也可以根据需要格式化输出。</p><p>下面是<code>date</code>命令中常用的<code>+</code>选项的用法：</p><ol><li><p>显示当前日期和时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure></li><li><p>格式化输出日期和时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span> +<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span><br></code></pre></td></tr></table></figure><p>这将按照<code>&quot;%Y-%m-%d %H:%M:%S&quot;</code>的格式输出当前日期和时间，例如<code>2024-06-07 12:30:45</code>。</p></li><li><p>显示当前日期（年、月、日）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span> +<span class="hljs-string">&quot;%Y-%m-%d&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>显示当前时间（时、分、秒）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span> +<span class="hljs-string">&quot;%H:%M:%S&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>显示当前星期几：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span> +<span class="hljs-string">&quot;%A&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>显示当前月份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span> +<span class="hljs-string">&quot;%B&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>显示当前时间戳（Unix 时间戳）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span> +<span class="hljs-string">&quot;%s&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>这些只是<code>date</code>命令的一些常见用法示例。通过结合不同的格式化选项，你可以根据需要输出各种日期和时间格式。</p><h3 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符"></a>管道操作符</h3><p>在Bash中，<code>|</code> 和 <code>&amp;</code> 是两个重要的操作符，用于控制命令之间的输入输出和后台执行。</p><ol><li><code>|</code> 管道操作符：<code>|</code> 可以将一个命令的输出传递给另一个命令作为输入。这种方式可以实现命令之间的协作和数据流转。例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">command1 | command2<br></code></pre></td></tr></table></figure><p>上面的命令将 <code>command1</code> 的输出作为 <code>command2</code> 的输入。</p><ol start="2"><li><code>&amp;</code> 后台执行操作符：在Bash中，<code>&amp;</code> 用于将命令放入后台执行，使得命令在后台运行而不阻塞当前终端。例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &amp;<br></code></pre></td></tr></table></figure><p>上面的命令将 <code>command</code> 放入后台执行。</p><p>关于Bash和Shell的区别：</p><ul><li>Shell 是一个通用术语，用来描述操作系统提供的命令行解释器。Bash 是 Linux 和其他类 Unix 系统上最常用的 Shell。因此，Bash 是 Shell 的一种。</li><li>Shell 是一个命令行解释器，用户可以通过 Shell 输入命令并与操作系统进行交互。Bash 是 GNU 项目的一部分，是 Bourne Shell (sh) 的增强版本，它提供了更多的功能和特性。</li><li>在大多数 Linux 系统中，默认的 Shell 是 Bash，但也有其他 Shell 可供选择，比如 Zsh、Fish 等。每种 Shell 都有自己独特的特性和语法。</li></ul><h3 id="grep-匹配"><a href="#grep-匹配" class="headerlink" title="grep 匹配"></a>grep 匹配</h3><p><code>grep</code> 是一个强大的文本搜索工具，通常用于在文件或标准输入中查找匹配特定模式的行，并将匹配的行打印出来。</p><p>下面是 <code>grep</code> 命令的一般格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [options] pattern [file...]<br></code></pre></td></tr></table></figure><ul><li><code>pattern</code> 是你要搜索的模式，可以是普通字符串或正则表达式。</li><li><code>file</code> 是要在其中搜索模式的文件。如果不指定文件，则 <code>grep</code> 会从标准输入中读取数据。</li></ul><p>以下是一些常用的 <code>grep</code> 选项：</p><ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：反转匹配，只输出不匹配的行。</li><li><code>-n</code>：显示匹配行的行号。</li><li><code>-c</code>：仅显示匹配行的计数。</li><li><code>-r</code>：递归地在目录中搜索文件。</li><li><code>-E</code>：启用扩展的正则表达式（支持更多的正则表达式语法）。</li></ul><p>示例用法：</p><ol><li><p>在文件中查找包含特定字符串 “hello” 的行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li><li><p>在多个文件中递归搜索包含 “error” 的行，并显示行号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n -r <span class="hljs-string">&quot;error&quot;</span> /path/to/directory<br></code></pre></td></tr></table></figure></li><li><p>使用正则表达式查找以 “2024” 开头的行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;^2024&quot;</span> file.txt<br></code></pre></td></tr></table></figure></li></ol><p>这些只是 <code>grep</code> 命令的一些基本用法，<code>grep</code> 还有许多其他选项和功能，你可以通过阅读 <code>grep</code> 的 man 手册或者在线文档来了解更多信息。</p><h3 id="grep-与管道操作符"><a href="#grep-与管道操作符" class="headerlink" title="grep 与管道操作符"></a>grep 与管道操作符</h3><p><code>grep</code>命令是一个强大的文本搜索工具，用于在文件或输入流中查找匹配指定模式的文本行。它通常与其他命令结合使用，以实现更复杂的文本处理和过滤操作。以下是一些常见的与<code>grep</code>命令连用的示例：</p><ol><li><strong>结合<code>cat</code>命令</strong>：<code>cat</code>命令用于显示文件内容，结合<code>grep</code>可以在文件中查找特定内容。例如，要查找包含关键字”error”的行，可以使用以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file.txt | grep <span class="hljs-string">&quot;error&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>结合<code>ls</code>命令</strong>：<code>ls</code>命令用于列出目录内容，结合<code>grep</code>可以过滤出特定文件或目录。例如，要列出当前目录中以”.txt”结尾的文件，可以使用以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> | grep <span class="hljs-string">&quot;\.txt$&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>结合<code>ps</code>命令</strong>：<code>ps</code>命令用于显示当前进程状态，结合<code>grep</code>可以过滤出特定进程。例如，要查找名为”firefox”的进程，可以使用以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep <span class="hljs-string">&quot;firefox&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>结合<code>find</code>命令</strong>：<code>find</code>命令用于在指定目录中查找文件，结合<code>grep</code>可以进一步过滤查找结果。例如，要在<code>/var/log</code>目录下查找包含关键字”error”的文件，可以使用以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /var/log -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> grep <span class="hljs-string">&quot;error&quot;</span> &#123;&#125; +<br></code></pre></td></tr></table></figure><p>这些是一些常见的与<code>grep</code>命令连用的示例，通过结合不同的命令，可以实现更加复杂和灵活的文本处理和搜索操作。</p><h3 id="添加Ubuntu镜像源"><a href="#添加Ubuntu镜像源" class="headerlink" title="添加Ubuntu镜像源"></a>添加Ubuntu镜像源</h3><p>查看ubuntu版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/issue<br></code></pre></td></tr></table></figure><p>一般路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/apt/source.list<br></code></pre></td></tr></table></figure><p>下附一些常见的镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#######   Ubuntu22.04LTS 清华镜像源   ###############</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">预发布软件源，不建议启用</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><h4 id="更新镜像源"><a href="#更新镜像源" class="headerlink" title="更新镜像源"></a>更新镜像源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update #更新软件列表<br>sudo apt-get upgrade # 更新本地软件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>搬运的旧文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>old</tag>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 基础用法</title>
    <link href="/2024/07/15/go-test/"/>
    <url>/2024/07/15/go-test/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>关于 go 基础语法简单教程。</p>          </div><h1 id="Go语言基本用法"><a href="#Go语言基本用法" class="headerlink" title="Go语言基本用法"></a>Go语言基本用法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在Go语言中，变量是用来存储数据的容器。变量声明的一般形式是使用 <code>var</code> 关键字，后面跟着变量名和变量类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variableName variableType<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>x := <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>在这种情况下，Go语言会自动推断出 <code>x</code> 的类型。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数在Go语言中使用<code>func</code>关键字定义。函数可以有参数和返回值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>Go语言中的选择结构主要是<code>if</code>和<code>switch</code>。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;x is positive&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;x is not positive&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>Go语言中的循环结构主要是<code>for</code>。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>你可以使用<code>make</code>函数来创建一个切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 创建一个长度为5的整数切片</span><br></code></pre></td></tr></table></figure><h4 id="访问切片元素"><a href="#访问切片元素" class="headerlink" title="访问切片元素"></a>访问切片元素</h4><p>你可以使用索引来访问切片的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 设置第一个元素的值为1</span><br>fmt.Println(s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure><h4 id="切片长度和容量"><a href="#切片长度和容量" class="headerlink" title="切片长度和容量"></a>切片长度和容量</h4><p>你可以使用<code>len</code>函数来获取切片的长度，使用<code>cap</code>函数来获取切片的容量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 输出5</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">// 输出5</span><br></code></pre></td></tr></table></figure><h4 id="添加元素到切片"><a href="#添加元素到切片" class="headerlink" title="添加元素到切片"></a>添加元素到切片</h4><p>你可以使用<code>append</code>函数来向切片添加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">6</span>) <span class="hljs-comment">// 在切片的末尾添加一个元素6</span><br></code></pre></td></tr></table></figure><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><p>你可以使用<code>[i:j]</code>的方式来获取切片的一个子切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t := s[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">// 获取s的第2个到第3个元素组成的切片</span><br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>你可以使用<code>make</code>函数来创建一个集合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>) <span class="hljs-comment">// 创建一个键类型为字符串，值类型为整数的集合</span><br></code></pre></td></tr></table></figure><h4 id="访问集合元素"><a href="#访问集合元素" class="headerlink" title="访问集合元素"></a>访问集合元素</h4><p>你可以使用键来访问集合的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 设置键为&quot;hello&quot;的元素的值为1</span><br>fmt.Println(m[<span class="hljs-string">&quot;hello&quot;</span>]) <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure><h4 id="检查键是否存在"><a href="#检查键是否存在" class="headerlink" title="检查键是否存在"></a>检查键是否存在</h4><p>当你访问一个不存在的键时，集合会返回该类型的零值。你可以使用两个值的形式来检查一个键是否存在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">value, exists := m[<span class="hljs-string">&quot;world&quot;</span>]<br><span class="hljs-keyword">if</span> exists &#123;<br>    fmt.Println(value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;key does not exist&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除集合元素"><a href="#删除集合元素" class="headerlink" title="删除集合元素"></a>删除集合元素</h4><p>你可以使用<code>delete</code>函数来删除集合的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">// 删除键为&quot;hello&quot;的元素</span><br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Go语言中，接口是一种类型，它定义了一组方法，但是这些方法不包含实现。以下是一些基本的使用方法：</p><p>你可以使用<code>type</code>关键字和<code>interface</code>关键字来定义一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Shape <span class="hljs-keyword">interface</span> &#123;<br>    Area() <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口表示任何具有<code>Area</code>方法的类型都满足<code>Shape</code>接口。</p><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>在Go语言中，接口的实现是隐式的。只要一个类型包含了接口所有的方法，那么它就实现了这个接口。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>    Radius <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> Area() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Pi * c.Radius * c.Radius<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Circle</code>类型就实现了<code>Shape</code>接口，因为它定义了<code>Area</code>方法。</p><h4 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h4><p>你可以使用接口类型的变量来存储实现了该接口的任何值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s Shape = Circle&#123;<span class="hljs-number">5.0</span>&#125;<br>fmt.Println(s.Area()) <span class="hljs-comment">// 输出78.53981633974483</span><br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在Go语言中，可以使用<code>*T</code>的形式来声明一个指针，其中<code>T</code>是指针指向的值的类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h4 id="获取变量的内存地址"><a href="#获取变量的内存地址" class="headerlink" title="获取变量的内存地址"></a>获取变量的内存地址</h4><p>可以使用<code>&amp;</code>操作符来获取一个变量的内存地址。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br>p = &amp;x<br></code></pre></td></tr></table></figure><h4 id="使用指针访问值"><a href="#使用指针访问值" class="headerlink" title="使用指针访问值"></a>使用指针访问值</h4><p>可以使用<code>*</code>操作符来访问指针指向的值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(*p) <span class="hljs-comment">// 输出2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>搬运的旧文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旧的笔记</title>
    <link href="/2024/07/15/old/"/>
    <url>/2024/07/15/old/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>这是我第三次把这个笔记搬运了。</p><p>其中大部分为 AI 生成的，对当时的我有意义的内容。本来该将这个博客分开，挂上不同的标签，便于查阅，但是<del>马上要回家了</del>，我就暂时不干了。</p>          </div><h1 id="杂乱的内容整理"><a href="#杂乱的内容整理" class="headerlink" title="杂乱的内容整理"></a>杂乱的内容整理</h1><blockquote><p>今天大致将原来所学过的知识整理一下，防止AI掉线<br>也算是回忆一下</p></blockquote><ul><li>目录</li><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B">1. c++ 有关操作</a></li><li>[2. ]</li></ul><h2 id="c-有关操作"><a href="#c-有关操作" class="headerlink" title="c++ 有关操作"></a>c++ 有关操作</h2><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><h4 id="单线程调用多个函数"><a href="#单线程调用多个函数" class="headerlink" title="单线程调用多个函数"></a>单线程调用多个函数</h4><p>C++多线程可以一个线程调用多个函数。下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-comment">// 函数1：打印数字</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Printing number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 函数2：打印字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Printing string: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个线程并调用两个函数</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">myThread</span><span class="hljs-params">([]()&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        printNumber(<span class="hljs-number">42</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        printString(<span class="hljs-string">&quot;Hello, world!&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    <span class="hljs-comment">// 等待线程执行完毕</span><br>    myThread.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个线程<code>myThread</code>，该线程同时调用了<code>printNumber</code>和<code>printString</code>两个函数。在<code>main</code>函数中，我们使用<code>join</code>等待线程执行完毕。当程序运行时，会输出以下结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Printing <span class="hljs-built_in">number</span>: <span class="hljs-number">42</span><br>Printing <span class="hljs-built_in">string</span>: Hello, world!<br></code></pre></td></tr></table></figure><p>这表明两个函数在同一个线程中被顺序调用。注意，这里的调用顺序是不确定的，因为线程的执行顺序取决于操作系统的调度策略。</p><h3 id="select-监视函数用法和读写操作"><a href="#select-监视函数用法和读写操作" class="headerlink" title="select 监视函数用法和读写操作"></a>select 监视函数用法和读写操作</h3><h4 id="select-函数用法"><a href="#select-函数用法" class="headerlink" title="select 函数用法"></a>select 函数用法</h4><p><code>select</code>函数是一个在Unix和类Unix系统上常用的系统调用，用于在一组文件描述符上等待某种事件的发生。它主要用于实现I&#x2F;O多路复用，允许程序同时监视多个文件描述符，一旦其中任何一个文件描述符准备好进行读、写或者出现异常，<code>select</code>函数就会返回，从而允许程序进行相应的I&#x2F;O操作。</p><p><code>select</code>函数的基本用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>nfds</code> 是待监视的文件描述符集合中所有文件描述符的最大值加1。</li><li><code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 分别是待监视的文件描述符集合，用于监视读、写和异常情况。</li><li><code>timeout</code> 是一个指向 <code>struct timeval</code> 结构的指针，用于设置超时时间。</li></ul><p>以下是一个简单的例子，说明如何使用<code>select</code>函数来监视文件描述符集合中的文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    fd_set readfds;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span>;</span><br>    <span class="hljs-type">int</span> retval;<br><br>    <span class="hljs-comment">// 清空并设置文件描述符集合</span><br>    FD_ZERO(&amp;readfds);<br>    FD_SET(STDIN_FILENO, &amp;readfds);<br><br>    <span class="hljs-comment">// 设置超时时间为5秒</span><br>    tv.tv_sec = <span class="hljs-number">5</span>;<br>    tv.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 监视文件描述符集合中的文件描述符</span><br>    retval = select(STDIN_FILENO + <span class="hljs-number">1</span>, &amp;readfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;tv);<br><br>    <span class="hljs-keyword">if</span> (retval == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;select()&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data is available now.\n&quot;</span>);<br>        <span class="hljs-comment">// 在这里进行读操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No data within 5 seconds.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>select</code>函数来监视标准输入（<code>STDIN_FILENO</code>），并设置了一个5秒的超时时间。如果在5秒内有数据可读，<code>select</code>函数将返回一个大于0的值，表示有数据可读；否则，将返回0，表示超时；如果出现错误，将返回-1。</p><p>其中，select所需fd产生方法：</p><p>在这段代码中，<code>FD_ZERO</code> 和 <code>FD_SET</code> 是宏，通常用于操作文件描述符集合。这些宏通常是为了方便地操纵文件描述符集合而定义的。以下是它们的用法：</p><ul><li><p><code>FD_ZERO(fd_set *set)</code>：用于将指定的文件描述符集合清空，即将其所有位都设置为0。</p></li><li><p><code>FD_SET(int fd, fd_set *set)</code>：用于将指定的文件描述符加入到文件描述符集合中。</p></li></ul><p>在上述代码中，首先通过调用 <code>FD_ZERO(&amp;readfds)</code> 将 <code>readfds</code> 文件描述符集合清空，以确保其中不包含任何文件描述符。接着，通过调用 <code>FD_SET(STDIN_FILENO, &amp;readfds)</code> 将标准输入文件描述符 <code>STDIN_FILENO</code> 加入到 <code>readfds</code> 文件描述符集合中，以便在接下来的 <code>select</code> 调用中监视标准输入。</p><p><code>STDIN_FILENO</code> 是一个宏定义，通常用于表示标准输入的文件描述符。在 POSIX 系统中，它的值通常是 0。因此，当我们使用 <code>STDIN_FILENO</code> 时，实际上是在使用文件描述符 0，表示标准输入流。</p><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p><code>read</code> 和 <code>write</code> 函数是在 Unix 和类 Unix 系统上用于进行文件 I&#x2F;O 操作的函数。</p><ul><li><p><code>read</code> 函数的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>这个函数用于从文件描述符 <code>fd</code> 所指向的文件中读取 <code>count</code> 个字节的数据到 <code>buf</code> 中。它返回实际读取的字节数，如果返回值为 0，表示已经到达文件末尾，返回值为 -1 表示出现了错误。</p></li><li><p><code>write</code> 函数的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><p>这个函数用于将 <code>buf</code> 中的 <code>count</code> 个字节数据写入到文件描述符 <code>fd</code> 所指向的文件中。它返回实际写入的字节数，如果返回值为 -1，表示出现了错误。</p></li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;output.txt&quot;</span>, O_CREAT | O_WRONLY, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer = <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>    <span class="hljs-type">ssize_t</span> bytes_written = write(fd, buffer, <span class="hljs-built_in">strlen</span>(buffer));<br>    <span class="hljs-keyword">if</span> (bytes_written == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully wrote %zd bytes\n&quot;</span>, bytes_written);<br>    &#125;<br><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先使用 <code>open</code> 函数打开一个名为 “output.txt” 的文件，然后使用 <code>write</code> 函数将字符串 “Hello, World!\n” 写入到这个文件中。最后关闭文件描述符。</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="简略掌握"><a href="#简略掌握" class="headerlink" title="简略掌握"></a>简略掌握</h4><p>在C++中，有许多用于操作字符串的函数。以下是一些常用的字符串操作函数，以及它们的详细用法：</p><ol><li>**<code>std::string::length</code>**：这个函数返回字符串的长度，即字符串中的字符数。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::cout &lt;&lt; str.<span class="hljs-built_in">length</span>();  <span class="hljs-comment">// 输出 13</span><br></code></pre></td></tr></table></figure><ol start="2"><li>**<code>std::string::substr</code>**：这个函数用于从字符串中提取子字符串。它有两个版本，一个版本接受一个参数，另一个版本接受两个参数。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string sub1 = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 从第一个位置开始提取子字符串</span><br>std::string sub2 = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 从第一个位置开始提取3个字符的子字符串</span><br>std::cout &lt;&lt; sub1 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Hello, World!&quot;</span><br>std::cout &lt;&lt; sub2 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Hel&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>**<code>std::string::find</code>**：这个函数用于在字符串中查找子字符串。如果找到了，它会返回子字符串的第一个字符在字符串中的位置；如果没有找到，它会返回<code>std::string::npos</code>。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">size_t</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">if</span> (pos != std::string::npos) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found at position &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Found at position 7&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>**<code>std::string::replace</code>**：这个函数用于替换字符串中的子字符串。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Hi&quot;</span>);  <span class="hljs-comment">// 用&quot;Hi&quot;替换从第一个位置开始的5个字符</span><br>std::cout &lt;&lt; str &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Hi, World!&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>**<code>std::string::erase</code>**：这个函数用于删除字符串中的字符。它有两个版本，一个版本接受一个参数，另一个版本接受两个参数。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 删除从第一个位置开始的5个字符</span><br>std::cout &lt;&lt; str &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;World!&quot;</span><br></code></pre></td></tr></table></figure><ol start="6"><li>**<code>std::string::c_str</code>**：这个函数用于返回一个指向以空字符结尾的字符数组的指针，这个字符数组包含了字符串的内容。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = str.<span class="hljs-built_in">c_str</span>();<br>std::cout &lt;&lt; cstr &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><h4 id="erase-用法"><a href="#erase-用法" class="headerlink" title="erase 用法"></a>erase 用法</h4><p>在C++中，<code>erase</code>是<code>std::string</code>类的一个成员函数，用于从字符串中删除指定位置的字符或一定范围内的字符。它有多种用法，以下是一些详细的例子：</p><ol><li><strong>删除单个字符</strong>：你可以使用<code>erase</code>来删除字符串中的单个字符。例如，以下代码将从字符串<code>str</code>的第一个位置开始删除一个字符：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 删除从第一个位置开始的一个字符</span><br>std::cout &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;ello&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>删除一定范围内的字符</strong>：你也可以使用<code>erase</code>来删除字符串中的一定范围内的字符。例如，以下代码将从字符串<code>str</code>的第一个位置开始删除3个字符：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 删除从第一个位置开始的3个字符</span><br>std::cout &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;lo&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>删除所有满足条件的字符</strong>：你可以使用<code>erase</code>和<code>std::remove_if</code>算法来删除字符串中所有满足某个条件的字符。例如，以下代码将从字符串<code>str</code>中删除所有的空格：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>str.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove_if</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), ::isspace), str.<span class="hljs-built_in">end</span>());<br>std::cout &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;HelloWorld&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>std::remove_if</code>算法会将满足<code>::isspace</code>条件的字符移到字符串的末尾，然后<code>erase</code>函数会删除这些字符。</p><h4 id="substr-用法举例"><a href="#substr-用法举例" class="headerlink" title="substr 用法举例"></a>substr 用法举例</h4><p>在C++中，<code>substr</code>是<code>std::string</code>类的一个成员函数，用于从字符串中提取子字符串。它有两个版本，一个版本接受一个参数，另一个版本接受两个参数。以下是详细的例子：</p><ol><li><strong>接受一个参数的版本</strong>：这个版本的<code>substr</code>函数接受一个参数，这个参数是从哪个位置开始提取子字符串。例如，以下代码将从字符串<code>str</code>的第一个位置开始提取子字符串：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string sub = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 从第一个位置开始提取子字符串</span><br>std::cout &lt;&lt; sub;  <span class="hljs-comment">// 输出 &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>接受两个参数的版本</strong>：这个版本的<code>substr</code>函数接受两个参数，第一个参数是从哪个位置开始提取子字符串，第二个参数是提取多少个字符。例如，以下代码将从字符串<code>str</code>的第一个位置开始提取3个字符的子字符串：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::string sub = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 从第一个位置开始提取3个字符的子字符串</span><br>std::cout &lt;&lt; sub;  <span class="hljs-comment">// 输出 &quot;Hel&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>substr</code>函数从字符串<code>str</code>的第一个位置开始提取3个字符的子字符串，然后将这个子字符串赋值给<code>sub</code>。</p><h4 id="stof-stoi-用法举例"><a href="#stof-stoi-用法举例" class="headerlink" title="stof&#x2F;stoi 用法举例"></a>stof&#x2F;stoi 用法举例</h4><p><code>std::stof</code>是C++标准库中的一个函数，用于将字符串转换为单精度浮点数（float）。它的用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">stof</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* idx = <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>str</code>：要转换为浮点数的字符串。</li><li><code>idx</code>：可选参数，指向存储转换结束位置的指针。</li></ul><p>以下是一个示例，演示了如何使用<code>std::stof</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;3.14159&quot;</span>;<br>    <span class="hljs-type">size_t</span> idx;  <span class="hljs-comment">// 用于存储转换结束位置的索引</span><br>    <span class="hljs-type">float</span> f = std::<span class="hljs-built_in">stof</span>(str, &amp;idx);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The converted float is &quot;</span> &lt;&lt; f &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The index of the next character after the float is &quot;</span> &lt;&lt; idx &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将字符串”3.14159”转换为浮点数，并打印出转换后的浮点数以及转换结束位置的索引。</p><p>当使用<code>std::stoi</code>时，你需要提供以下参数：</p><ol><li><strong>字符串</strong>：这是要转换为整数的输入字符串。</li><li><strong>指向size_t类型对象的指针</strong>（可选）：用于存储转换后的最后一个字符的索引。如果不需要此信息，可以将其设置为nullptr。</li><li><strong>基数</strong>（可选，默认为10）：指定数字的进制。例如，如果你想解析一个十六进制数字，你可以将基数设置为16。</li></ol><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;12345&quot;</span>;<br>    <span class="hljs-type">size_t</span> pos; <span class="hljs-comment">// 用于存储转换后的最后一个字符的索引</span><br>    <span class="hljs-type">int</span> num = std::<span class="hljs-built_in">stoi</span>(str, &amp;pos);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The integer value is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The index of the last character processed is: &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，字符串”12345”被转换为整数12345并存储在变量<code>num</code>中。变量<code>pos</code>将包含转换后的最后一个字符的索引。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>在C++中，可以通过重载()运算符来实现仿函数（Function Object）。一个常见的示例是实现一个加法仿函数，让其能够像函数一样接受整数参数并返回加法结果。以下是一个简单的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &amp;ltiostream&amp;gt</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x + <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Adder adder;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">adder</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 实际上调用了 adder.operator()(5)</span><br><br>    std::cout &amp;lt&amp;lt <span class="hljs-string">&quot;Result: &quot;</span> &amp;lt&amp;lt result &amp;lt&amp;lt std::endl; <span class="hljs-comment">// 输出: Result: 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Adder</code>类重载了<code>()</code>运算符，使得我们可以像调用函数一样使用<code>Adder</code>类的对象<code>adder</code>，并传入一个整数参数。当我们调用<code>adder(5)</code>时，实际上会调用<code>Adder</code>类中重载的<code>()</code>运算符函数，这个函数接受一个整数参数并返回<code>x + 10</code>的结果，最终输出结果为15。</p><h2 id="linux-有关整理"><a href="#linux-有关整理" class="headerlink" title="linux 有关整理"></a>linux 有关整理</h2><blockquote><p>这里我就挑几个重要的写<br>太多了，来不及粘贴</p></blockquote><h3 id="ssh-协议连接"><a href="#ssh-协议连接" class="headerlink" title="ssh 协议连接"></a>ssh 协议连接</h3><p>这个命令是用于通过SSH协议（Secure Shell）连接到远程主机的命令。具体来说，<code>ssh non@192.168.51.8</code>的含义如下：</p><ul><li><code>ssh</code>: 是用于启动SSH客户端的命令。</li><li><code>non</code>: 这是一个用户名，表示您希望使用用户名<code>non</code>来连接到远程主机。</li><li><code>192.168.51.8</code>: 这是远程主机的IP地址或主机名，表示您希望连接到IP地址为<code>192.168.51.8</code>的远程主机。</li></ul><p>因此，当您运行<code>ssh non@192.168.51.8</code>时，您正在尝试使用用户名<code>non</code>通过SSH连接到IP地址为<code>192.168.51.8</code>的远程主机。如果输入密码正确并且远程主机允许该用户通过SSH登录，您将成功建立连接并获得远程主机的Shell访问权限。</p><p>通过SSH协议（Secure Shell）连接到服务器或电脑是一种安全的远程访问方式，可以在不安全的网络环境下进行加密通信。下面是通过SSH连接到服务器或电脑的一般步骤：</p><h4 id="连接到服务器或电脑的步骤："><a href="#连接到服务器或电脑的步骤：" class="headerlink" title="连接到服务器或电脑的步骤："></a>连接到服务器或电脑的步骤：</h4><ol><li><p><strong>打开终端</strong>：在本地计算机上打开终端或命令行界面。</p></li><li><p><strong>输入SSH命令</strong>：使用以下命令连接到目标主机：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> username<span class="hljs-variable">@hostname</span><br></code></pre></td></tr></table></figure><p>其中，<code>username</code>是您在远程主机上的用户名，<code>hostname</code>是远程主机的IP地址或域名。</p></li><li><p><strong>输入密码</strong>：如果是第一次连接，系统可能会询问是否要添加主机到已知主机列表中，输入<code>yes</code>后会要求输入密码。</p></li><li><p><strong>输入密码</strong>：输入您的远程主机密码（密码不会显示在屏幕上）。</p></li><li><p><strong>成功连接</strong>：如果密码正确，您将会成功连接到远程主机，可以开始在远程主机上执行命令。</p></li></ol><h4 id="SSH连接原理："><a href="#SSH连接原理：" class="headerlink" title="SSH连接原理："></a>SSH连接原理：</h4><ul><li><p><strong>加密通信</strong>：SSH通过加密技术确保通信过程中的数据传输安全，包括身份验证、命令传输和数据传输等。</p></li><li><p><strong>公钥加密</strong>：SSH使用公钥加密技术来进行身份验证和建立安全连接。当您连接到远程主机时，客户端和服务器之间会交换公钥，然后使用这些密钥来加密通信。</p></li><li><p><strong>安全认证</strong>：在连接时，SSH要求用户提供密码或者使用公钥进行认证。这种方式可以防止未经授权的用户访问远程主机。</p></li><li><p><strong>端到端加密</strong>：SSH协议提供端到端的加密，确保数据在传输过程中不会被窃取或篡改。</p></li></ul><p>总的来说，SSH协议通过加密通信、安全认证和端到端加密等技术，为用户提供了一种安全、加密的远程访问方式，使得用户可以在不安全的网络环境下安全地访问远程主机。ii</p><h3 id="linux-联网操作："><a href="#linux-联网操作：" class="headerlink" title="linux 联网操作："></a>linux 联网操作：</h3><p>Linux服务器连接到互联网通常需要配置网络连接。以下是连接Linux服务器到互联网的一般步骤：</p><ol><li><p><strong>检查网络连接</strong>：首先，确保服务器的网络接口是正常连接的，可以通过以下命令检查网络接口状态：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置网络接口</strong>：您可以通过编辑网络配置文件来配置网络接口。在大多数Linux发行版中，网络配置文件通常位于<code>/etc/network/interfaces</code>或者<code>/etc/sysconfig/network-scripts/ifcfg-&lt;interface&gt;</code>。</p></li><li><p><strong>配置IP地址</strong>：为服务器分配一个IP地址，可以是静态IP地址或者动态分配IP地址（DHCP）。</p></li><li><p><strong>配置网关</strong>：设置默认网关，以便服务器知道如何路由到互联网。</p></li><li><p><strong>配置DNS</strong>：配置DNS服务器，以便服务器能够解析域名。</p></li><li><p><strong>重启网络服务</strong>：在完成配置后，您可能需要重启网络服务以使更改生效。您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart networking<br></code></pre></td></tr></table></figure></li><li><p><strong>测试连接</strong>：最后，您可以通过ping命令测试服务器是否能够访问互联网。例如，尝试ping一个已知的互联网地址：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> www.google.com<br></code></pre></td></tr></table></figure></li></ol><p>通过以上步骤，您可以配置Linux服务器的网络连接，使其能够连接到互联网并进行通信。如果您遇到任何问题，可以检查网络配置文件以及网络连接状态，以便进行故障排除。</p><h3 id="bashrc-配置bash"><a href="#bashrc-配置bash" class="headerlink" title="bashrc 配置bash"></a>bashrc 配置bash</h3><p>要让Linux命令窗口永久具有颜色高亮效果，您可以通过修改终端配置文件来实现。具体步骤可能会因终端类型和Linux发行版而有所不同，以下是一般步骤：</p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li><p><strong>找到终端配置文件</strong>：不同的终端可能会使用不同的配置文件。一般来说，常见的终端配置文件包括：</p><ul><li><strong>Bash shell</strong>：<code>~/.bashrc</code> 或 <code>~/.bash_profile</code></li><li><strong>Zsh shell</strong>：<code>~/.zshrc</code></li><li><strong>GNOME终端</strong>：可以在终端的首选项中设置</li><li><strong>其他终端</strong>：具体取决于您使用的终端类型</li></ul></li><li><p><strong>编辑配置文件</strong>：使用文本编辑器打开相应的配置文件，添加设置文本颜色的命令。例如，您可以添加类似下面的命令来设置提示符为绿色：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;\[\033[0;32m\][\u@\h \W]\$ \[\033[0m\]&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将提示符设置为绿色。</p></li><li><p><strong>保存并生效</strong>：保存配置文件并使更改生效。您可以通过执行以下命令使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></li><li><p><strong>重新打开终端</strong>：关闭当前终端窗口并重新打开一个新的终端窗口，您应该能看到新的颜色设置生效。</p></li></ol><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>在编辑配置文件时，请确保您知道您在做什么，以免意外导致终端无法正常工作。</li><li>不同的终端可能需要不同的设置语法和命令，具体取决于您使用的终端类型。</li><li>永久更改终端颜色可能会影响可读性，因此请谨慎选择颜色设置。</li></ul><p>请根据您使用的终端类型和个人喜好，调整颜色设置以满足您的需求。</p><blockquote><p>注意事项：</p><p>bashrc 位置不同，作用范围也不同，分为home和root</p><p>root可以sudo -i开启root模式</p><p>bashrc还可以搞快捷键</p></blockquote><h2 id="docker-docker-compose-整理"><a href="#docker-docker-compose-整理" class="headerlink" title="docker&#x2F;docker-compose 整理"></a>docker&#x2F;docker-compose 整理</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Docker Compose 是一个用于定义和运行多个 Docker 容器应用的工具。它通过一个单独的 YAML 文件（通常命名为docker-compose.yml）来配置应用的服务，然后使用这个文件来创建和管理这些服务。Docker Compose 可以大大简化多容器应用的部署和管理过程。</p><h3 id="Docker-Compose-的工作原理："><a href="#Docker-Compose-的工作原理：" class="headerlink" title="Docker Compose 的工作原理："></a>Docker Compose 的工作原理：</h3><ol><li><p><strong>编写 docker-compose.yml 文件</strong>：用户首先需要编写一个 docker-compose.yml 文件，该文件定义了应用的服务、网络、卷等配置。在这个文件中，用户可以指定每个服务的镜像、端口映射、环境变量、依赖关系等信息。</p></li><li><p><strong>启动容器</strong>：用户使用 <code>docker-compose up</code> 命令来启动应用程序。Docker Compose 将会根据docker-compose.yml文件中的配置来启动所需的容器。</p></li><li><p><strong>构建镜像</strong>：如果在 docker-compose.yml 中指定的镜像不存在，Docker Compose 将会根据 Dockerfile 来构建镜像。Dockerfile 是一个包含了构建镜像所需指令的文本文件，定义了如何构建 Docker 镜像。Docker Compose 会自动查找当前目录下的 Dockerfile 来构建镜像。</p></li><li><p><strong>容器间通信</strong>：Docker Compose 会自动创建一个默认网络，所有在同一个 docker-compose.yml 文件中定义的服务都会连接到这个网络上。这样，不同的容器就可以通过服务名相互通信。</p></li></ol><h3 id="如何通过-yml-文件构建镜像和容器："><a href="#如何通过-yml-文件构建镜像和容器：" class="headerlink" title="如何通过 .yml 文件构建镜像和容器："></a>如何通过 .yml 文件构建镜像和容器：</h3><ol><li><p><strong>构建镜像</strong>：在 docker-compose.yml 文件中，可以使用 <code>build</code> 关键字指定构建镜像所需的信息，比如 Dockerfile 的路径。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">myservice:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile</span><br></code></pre></td></tr></table></figure></li><li><p><strong>构建容器</strong>：在 docker-compose.yml 文件中，定义了服务后，可以使用 <code>docker-compose up</code> 命令来构建并启动容器。如果镜像不存在，Docker Compose 会自动根据 Dockerfile 构建镜像，然后启动容器。</p></li></ol><h3 id="Dockerfile-在-Docker-Compose-中的作用："><a href="#Dockerfile-在-Docker-Compose-中的作用：" class="headerlink" title="Dockerfile 在 Docker Compose 中的作用："></a>Dockerfile 在 Docker Compose 中的作用：</h3><p>Dockerfile 是用来构建 Docker 镜像的脚本文件，定义了镜像的内容和构建方式。在 Docker Compose 中，Dockerfile 主要用于构建镜像，以及指定镜像的基础环境和依赖。</p><p>当在 docker-compose.yml 文件中使用 <code>build</code> 关键字指定了 Dockerfile 的路径后，Docker Compose 将会根据这个 Dockerfile 来构建镜像。Dockerfile 中的指令将会按顺序执行，以构建出最终的镜像。Docker Compose 可以根据 Dockerfile 中的指令构建出多个镜像，每个服务都可以有自己的 Dockerfile。</p><p>总之，Dockerfile 在 Docker Compose 中的作用是定义镜像的构建过程，包括基础镜像、依赖安装、文件拷贝等操作，以供 Docker Compose 使用。</p><h3 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h3><p><code>docker-compose.yml</code> 和 <code>Dockerfile</code> 是 Docker 中的两个不同概念，它们通常用于不同的目的并且不会直接冲突。</p><ul><li><p><strong>Dockerfile</strong>: 用于构建 Docker 镜像的文件，其中包含了构建镜像所需的指令，比如基础镜像、安装软件、设置环境变量、拷贝文件等。通过执行 <code>docker build</code> 命令可以根据 Dockerfile 构建出一个镜像。</p></li><li><p><strong>docker-compose.yml</strong>: 用于定义和运行多个 Docker 容器的配置文件，可以一次性启动多个容器，并且定义了容器之间的关系、网络设置、卷挂载等。通过执行 <code>docker-compose up</code> 命令可以根据 <code>docker-compose.yml</code> 启动整个应用的容器组。</p></li></ul><p>虽然它们有不同的作用，但在某些情况下，<code>docker-compose.yml</code> 文件中也可以包含一些与 <code>Dockerfile</code> 相关的指令，比如 <code>build</code> 指令用于构建镜像。下面是一个简单的示例：</p><p>假设有一个应用，需要构建一个镜像并运行两个容器：一个是 Web 服务器，一个是数据库。</p><p><strong>Dockerfile</strong> 可能如下所示：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 基于官方的 Node 镜像</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">14</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 拷贝应用代码到工作目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 安装依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install</span><br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-comment"># 启动应用</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;npm&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>docker-compose.yml</strong> 可能如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">example</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>docker-compose.yml</code> 中的 <code>build: .</code> 指令告诉 <code>docker-compose</code> 使用当前目录下的 <code>Dockerfile</code> 构建 <code>web</code> 服务的镜像。这样可以通过 <code>docker-compose up</code> 一次性启动两个容器，而不需要手动执行 <code>docker build</code> 和 <code>docker run</code> 命令。</p><p>因此，虽然 <code>docker-compose.yml</code> 中可以包含一些与 <code>Dockerfile</code> 相关的指令，但它们的作用和目的不同，不会直接冲突。</p><h2 id="奇怪的命令和软件安装"><a href="#奇怪的命令和软件安装" class="headerlink" title="奇怪的命令和软件安装"></a>奇怪的命令和软件安装</h2><h3 id="apt-install-安装路径"><a href="#apt-install-安装路径" class="headerlink" title="apt install 安装路径"></a>apt install 安装路径</h3><p>在默认情况下，<code>apt install</code> 命令会将软件包安装到系统中预定义的目录结构中。在大多数情况下，Debian和Ubuntu系统中的软件包通常会被安装到以下目录中：</p><ul><li>可执行文件通常会被安装到 <code>/usr/bin/</code> 目录下。</li><li>库文件通常会被安装到 <code>/usr/lib/</code> 目录下。</li><li>配置文件通常会被安装到 <code>/etc/</code> 目录下。</li><li>文档通常会被安装到 <code>/usr/share/doc/</code> 目录下。</li><li>其他资源文件通常会被安装到 <code>/usr/share/</code> 目录下。</li></ul><p>需要注意的是，具体的安装路径可能会因软件包而异，有些软件包可能会有自定义的安装路径。如果你想要查看特定软件包的安装路径，可以使用<code>dpkg</code>命令来查询已安装软件包的文件列表，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -L package_name<br></code></pre></td></tr></table></figure><p>这将列出特定软件包安装的文件路径。</p><h3 id="自动联网更新时间"><a href="#自动联网更新时间" class="headerlink" title="自动联网更新时间"></a>自动联网更新时间</h3><blockquote><p>以ntp为例，或者可以使用chrony</p></blockquote><h4 id="安装ntp"><a href="#安装ntp" class="headerlink" title="安装ntp"></a>安装ntp</h4><ol><li><p><strong>检查并更新你的系统时间</strong>：<br>你可以使用 <code>date</code> 命令查看当前系统时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><p>如果时间不正确，你可以使用 <code>sudo</code> 权限手动设置正确的时间，或者更好的是，使用 NTP（网络时间协议）自动同步时间。</p></li><li><p><strong>使用 NTP 自动同步时间</strong>：<br>安装 <code>ntp</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install ntp<br></code></pre></td></tr></table></figure><p>安装完成后，NTP 服务会启动并尝试自动同步你的系统时间。</p></li><li><p><strong>手动设置系统时间</strong>：<br>如果你不想使用 NTP，也可以手动设置系统时间。例如，设置为 2023年10月1日12:00可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">date</span> --<span class="hljs-built_in">set</span>=<span class="hljs-string">&quot;2023-10-01 12:00:00&quot;</span><br></code></pre></td></tr></table></figure><p>确保使用你的本地时间。</p></li><li><p>**重新运行 <code>sudo apt update</code>**：<br>在调整时间之后，重新运行更新命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure></li></ol><h4 id="启动ntp"><a href="#启动ntp" class="headerlink" title="启动ntp"></a>启动ntp</h4><ol><li>确定初始化系统管理器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps --no-headers -o <span class="hljs-built_in">comm</span> 1<br></code></pre></td></tr></table></figure><p>如果返回的不是<code>systemd</code>，你需要用我的方法<code>init</code></p><ol start="2"><li>确定启动名称</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /etc/init.d/<br></code></pre></td></tr></table></figure><p>查看最接近<code>nfds</code>的名称，这是我的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@姒克禹:/home/cofallen/Code/Cpp# <span class="hljs-built_in">ls</span> /etc/init.d/<br>apparmor          cups               kmod          procps                       ufw<br>apport            dbus               lightdm       pulseaudio-enable-autospawn  unattended-upgrades<br>bluetooth         hwclock.sh         ntpsec        rsync                        uuidd<br>console-setup.sh  irqbalance         plymouth      saned                        whoopsie<br>cron              keyboard-setup.sh  plymouth-log  screen-cleanup               x11-commo<br></code></pre></td></tr></table></figure><p>一眼看出<code>ntpsec</code>是吧。</p><ol start="3"><li>启动进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@姒克禹:/home/cofallen/Code/Cpp# <span class="hljs-built_in">sudo</span> service ntpsec start<br> * Starting NTP server ntpd                                                                                     2024-05-20T22:18:10 ntpd[20837]: INIT: ntpd ntpsec-1.2.2: Starting<br>2024-05-20T22:18:10 ntpd[20837]: INIT: Command line: /usr/sbin/ntpd -p /run/ntpd.pid -c /etc/ntpsec/ntp.conf -g -N -u ntpsec:ntpsec<br></code></pre></td></tr></table></figure><h2 id="git-文件"><a href="#git-文件" class="headerlink" title="git 文件"></a>git 文件</h2><p><code>.git</code> 文件夹是 Git 仓库的核心，它包含了跟踪项目版本历史和管理文件更改所需的所有信息。以下是 <code>.git</code> 文件夹中一些重要文件和文件夹的解释：</p><ol><li><p><strong>branches</strong>:</p><ul><li>包含指向各个分支头部的指针文件。</li></ul></li><li><p><strong>hooks</strong>:</p><ul><li>包含客户端或服务器上的钩子脚本，这些脚本在特定的重要动作发生时会被执行。</li></ul></li><li><p><strong>info</strong>:</p><ul><li>包含全局性的排除文件（global exclude file）。</li></ul></li><li><p><strong>objects</strong>:</p><ul><li>存储所有数据内容的地方。Git 使用一种称为“哈希”的机制来对内容进行索引，这些内容可以是文件内容或者目录结构。</li></ul></li><li><p><strong>refs</strong>:</p><ul><li>存储指向数据（如提交对象）的提交对象（commit objects）的指针。这里也包含了远程仓库的引用。</li></ul></li><li><p><strong>config</strong>:</p><ul><li>包含了本地仓库的配置信息，例如用户信息、远程仓库地址等。</li></ul></li><li><p><strong>HEAD</strong>:</p><ul><li>指示当前所在分支的符号引用。</li></ul></li><li><p><strong>index</strong>:</p><ul><li>包含了暂存区的内容，用于记录下一次提交的文件状态。</li></ul></li><li><p><strong>logs</strong>:</p><ul><li>包含引用日志，可以用来查看每个引用的更新历史。</li></ul></li></ol><p>这些文件和文件夹组成了 Git 仓库的基本结构，负责跟踪文件变化、存储元数据和配置信息、以及维护分支和标签等重要功能。</p>]]></content>
    
    
    <categories>
      
      <category>搬运的旧文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>old</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 空间内存分配</title>
    <link href="/2024/07/14/build-page-by-hexo/"/>
    <url>/2024/07/14/build-page-by-hexo/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>简要的关于 <code>c</code> 的应用。</p><p>可以在 VOFA 中加入，简化代码调用体积。</p>          </div><h2 id="c-分配空间"><a href="#c-分配空间" class="headerlink" title="c 分配空间"></a>c 分配空间</h2><h3 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-type">float</span> *floatArray;<br>    <span class="hljs-type">char</span> *charArray;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 假设有5个浮点数和4个字符</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> *<span class="hljs-title">data</span> =</span> (<span class="hljs-keyword">struct</span> Data *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Data));<br>    data-&gt;floatArray = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>));<br>    data-&gt;charArray = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">4</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br><br>    <span class="hljs-comment">// 现在你可以访问和操作data结构中的浮点数和字符数组了</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(data-&gt;floatArray);<br>    <span class="hljs-built_in">free</span>(data-&gt;charArray);<br>    <span class="hljs-built_in">free</span>(data);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拼接不同类型空间"><a href="#拼接不同类型空间" class="headerlink" title="拼接不同类型空间"></a>拼接不同类型空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n1 = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> n2 = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 分配第一个数组（整数数组）</span><br>    <span class="hljs-type">int</span> *intArray = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(n1, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++) &#123;<br>        intArray[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配第二个数组（浮点数数组）</span><br>    <span class="hljs-type">float</span> *floatArray = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(n2, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; i++) &#123;<br>        floatArray[i] = i + <span class="hljs-number">0.5</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个新的数组，将intArray和floatArray拼接起来</span><br>    <span class="hljs-type">int</span> totalSize = n1 + n2;<br>    <span class="hljs-type">void</span> *combinedArray = <span class="hljs-built_in">malloc</span>((n1 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) + (n2 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)));<br><br>    <span class="hljs-comment">// 将intArray和floatArray的内容拷贝到combinedArray</span><br>    <span class="hljs-built_in">memcpy</span>(combinedArray, intArray, n1 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span> *)combinedArray + n1 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), floatArray, n2 * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>));<br><br>    <span class="hljs-comment">// 现在combinedArray包含了intArray和floatArray的元素</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(intArray);<br>    <span class="hljs-built_in">free</span>(floatArray);<br>    <span class="hljs-built_in">free</span>(combinedArray);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态创建二维数组"><a href="#动态创建二维数组" class="headerlink" title="动态创建二维数组"></a>动态创建二维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 分配二维数组</span><br>    <span class="hljs-type">int</span> **array2D = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">calloc</span>(rows, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span> *));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        array2D[i] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(cols, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 现在你可以使用array2D作为一个3x4的二维数组来存储和访问数据</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-built_in">free</span>(array2D[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(array2D);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));  <span class="hljs-comment">// 分配初始内存空间</span><br>    <span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;Hello&quot;</span>);<br><br>    <span class="hljs-comment">// 扩展字符串</span><br>    str = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(str, <span class="hljs-number">11</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));  <span class="hljs-comment">// 重新分配内存</span><br>    <span class="hljs-built_in">strcat</span>(str, <span class="hljs-string">&quot; World&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);  <span class="hljs-comment">// 输出 &quot;Hello World&quot;</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(str);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>搬运的旧文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
